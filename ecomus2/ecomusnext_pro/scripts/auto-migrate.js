#!/usr/bin/env node

/**
 * Script de migration automatique pour unifier les templates Ecomus
 * Ce script migre automatiquement les composants dupliqu√©s vers le syst√®me unifi√©
 */

const fs = require('fs');
const path = require('path');

const colors = {
  reset: '\x1b[0m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m'
};

function log(message, color = 'reset') {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

class AutoMigrator {
  constructor() {
    this.projectRoot = process.cwd();
    this.homesDir = path.join(this.projectRoot, 'components', 'homes');
    this.sharedDir = path.join(this.homesDir, 'shared');
    
    this.stats = {
      migrated: 0,
      updated: 0,
      errors: []
    };

    // Composants prioritaires √† migrer en premier
    this.priorityComponents = [
      'Hero',
      'Categories', 
      'Products',
      'Collections',
      'Testimonials',
      'Blogs',
      'Newsletter',
      'Marquee',
      'Countdown',
      'Footer',
      'Brands',
      'Banner',
      'Features',
      'Lookbook'
    ];
  }

  async autoMigrate() {
    log('\nü§ñ MIGRATION AUTOMATIQUE VERS LE SYST√àME UNIFI√â', 'cyan');
    log('=' * 60, 'cyan');

    // 1. Assurer que le r√©pertoire shared existe
    this.ensureSharedDirectory();

    // 2. Migrer les composants prioritaires
    await this.migratePriorityComponents();

    // 3. Cr√©er les fichiers de configuration unifi√©s
    await this.createUnifiedConfigs();

    // 4. G√©n√©rer les imports unifi√©s
    await this.generateUnifiedImports();

    // 5. Rapport final
    this.generateFinalReport();
  }

  ensureSharedDirectory() {
    if (!fs.existsSync(this.sharedDir)) {
      fs.mkdirSync(this.sharedDir, { recursive: true });
      log(`‚úÖ R√©pertoire shared cr√©√©: ${this.sharedDir}`, 'green');
    }
  }

  async migratePriorityComponents() {
    log('\nüì¶ Migration des composants prioritaires...', 'blue');

    for (const component of this.priorityComponents) {
      await this.migrateComponent(component);
    }
  }

  async migrateComponent(componentName) {
    try {
      const sharedPath = path.join(this.sharedDir, `${componentName}.jsx`);
      
      // Si le composant existe d√©j√† dans shared, on passe
      if (fs.existsSync(sharedPath)) {
        log(`‚è≠Ô∏è  ${componentName} d√©j√† dans shared/`, 'yellow');
        return;
      }

      // Chercher le premier exemplaire du composant
      const firstInstance = this.findFirstComponentInstance(componentName);
      
      if (!firstInstance) {
        log(`‚ùå Aucune instance trouv√©e pour ${componentName}`, 'red');
        return;
      }

      // Lire le contenu du composant source
      const sourceContent = fs.readFileSync(firstInstance.path, 'utf8');
      
      // G√©n√©rer le composant unifi√©
      const unifiedContent = this.generateUnifiedComponent(componentName, sourceContent);
      
      // √âcrire le composant unifi√©
      fs.writeFileSync(sharedPath, unifiedContent);
      
      log(`‚úÖ ${componentName} migr√© vers shared/`, 'green');
      this.stats.migrated++;
      
    } catch (error) {
      log(`‚ùå Erreur lors de la migration de ${componentName}: ${error.message}`, 'red');
      this.stats.errors.push(`${componentName}: ${error.message}`);
    }
  }

  findFirstComponentInstance(componentName) {
    try {
      const homesDirs = fs.readdirSync(this.homesDir)
        .filter(item => {
          const itemPath = path.join(this.homesDir, item);
          return fs.statSync(itemPath).isDirectory() && item !== 'shared';
        });

      for (const dir of homesDirs) {
        const componentPath = path.join(this.homesDir, dir, `${componentName}.jsx`);
        if (fs.existsSync(componentPath)) {
          return {
            template: dir,
            path: componentPath
          };
        }
      }
      return null;
    } catch (error) {
      return null;
    }
  }

  generateUnifiedComponent(componentName, sourceContent) {
    // Template de composant unifi√©
    const unifiedTemplate = `import React from 'react';
import Link from 'next/link';
import Image from 'next/image';

const ${componentName} = ({ 
  variant = "default",
  title,
  subtitle,
  className = "",
  ...props 
}) => {
  const getVariantClasses = () => {
    switch (variant) {
      case 'electronic':
        return 'bg-gradient-to-r from-blue-500 to-indigo-600 text-white';
      case 'fashion':
        return 'bg-gradient-to-r from-pink-500 to-purple-600 text-white';
      case 'cosmetic':
        return 'bg-gradient-to-r from-purple-500 to-pink-600 text-white';
      case 'dark':
        return 'bg-gray-900 text-white';
      default:
        return 'bg-white text-gray-900';
    }
  };

  // TODO: Int√©grer la logique sp√©cifique du composant original
  // Source: ${sourceContent.split('\n')[0]}
  
  return (
    <section className={\`py-16 md:py-24 \${getVariantClasses()} \${className}\`}>
      <div className="container mx-auto px-4">
        {title && (
          <div className="text-center mb-12">
            <h2 className="text-3xl md:text-4xl font-bold mb-4">
              {title}
            </h2>
            {subtitle && (
              <p className="text-lg opacity-90 max-w-2xl mx-auto">
                {subtitle}
              </p>
            )}
          </div>
        )}
        
        {/* Contenu principal du composant */}
        <div className="text-center">
          <p className="text-lg opacity-75">
            üîÑ Composant ${componentName} unifi√© - En cours de migration
          </p>
          <p className="text-sm mt-2 opacity-60">
            Variant actuel: {variant}
          </p>
        </div>
      </div>
    </section>
  );
};

export default ${componentName};`;

    return unifiedTemplate;
  }

  async createUnifiedConfigs() {
    log('\n‚öôÔ∏è Cr√©ation des configurations unifi√©es...', 'blue');

    // Cr√©er un mapping template -> configuration
    const templateMappings = this.generateTemplateMappings();
    
    const configContent = `// Configuration automatiquement g√©n√©r√©e par le script de migration
export const AUTO_GENERATED_CONFIGS = ${JSON.stringify(templateMappings, null, 2)};

// Fonction pour obtenir la configuration d'un template
export const getAutoConfig = (templateId) => {
  return AUTO_GENERATED_CONFIGS[templateId] || AUTO_GENERATED_CONFIGS['default'];
};

export default {
  AUTO_GENERATED_CONFIGS,
  getAutoConfig
};`;

    const configPath = path.join(this.projectRoot, 'lib', 'auto-generated-configs.js');
    fs.writeFileSync(configPath, configContent);
    
    log('‚úÖ Configuration unifi√©e g√©n√©r√©e', 'green');
  }

  generateTemplateMappings() {
    const mappings = {};
    
    try {
      const homesDirs = fs.readdirSync(this.homesDir)
        .filter(item => {
          const itemPath = path.join(this.homesDir, item);
          return fs.statSync(itemPath).isDirectory() && item !== 'shared';
        });

      homesDirs.forEach((template, index) => {
        const templatePath = path.join(this.homesDir, template);
        const components = fs.readdirSync(templatePath)
          .filter(file => file.endsWith('.jsx') || file.endsWith('.tsx'))
          .map(file => path.parse(file).name)
          .filter(name => name !== 'index');

        mappings[template] = {
          name: this.formatTemplateName(template),
          order: index + 1,
          components: components,
          sections: components.map((comp, i) => ({
            id: `${comp.toLowerCase()}-1`,
            component: comp.toLowerCase(),
            enabled: true,
            order: i + 1,
            props: {
              variant: this.guessVariant(template),
              title: `${comp} Section`,
              subtitle: `Generated from ${template}`
            }
          }))
        };
      });

      // Configuration par d√©faut
      mappings['default'] = {
        name: 'Default Template',
        order: 0,
        components: this.priorityComponents.map(c => c.toLowerCase()),
        sections: this.priorityComponents.map((comp, i) => ({
          id: `${comp.toLowerCase()}-1`,
          component: comp.toLowerCase(),
          enabled: true,
          order: i + 1,
          props: {
            variant: 'default',
            title: `${comp} Section`
          }
        }))
      };

    } catch (error) {
      log(`‚ùå Erreur lors de la g√©n√©ration des mappings: ${error.message}`, 'red');
    }

    return mappings;
  }

  formatTemplateName(template) {
    return template
      .split('-')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');
  }

  guessVariant(template) {
    if (template.includes('electronic')) return 'electronic';
    if (template.includes('fashion')) return 'fashion';
    if (template.includes('cosmetic') || template.includes('beauty')) return 'cosmetic';
    if (template.includes('dark')) return 'dark';
    return 'default';
  }

  async generateUnifiedImports() {
    log('\nüìÅ G√©n√©ration des imports unifi√©s...', 'blue');

    const importContent = `// Imports automatiquement g√©n√©r√©s pour le syst√®me unifi√©
// Ce fichier centralise tous les composants shared

${this.priorityComponents.map(component => 
  `export { default as ${component} } from './shared/${component}';`
).join('\n')}

// Registry unifi√© des composants
export const UNIFIED_COMPONENTS = {
${this.priorityComponents.map(component => 
  `  ${component.toLowerCase()}: ${component},`
).join('\n')}
};

// Fonction helper pour obtenir un composant
export const getUnifiedComponent = (name) => {
  const componentName = name.toLowerCase();
  return UNIFIED_COMPONENTS[componentName];
};

export default UNIFIED_COMPONENTS;`;

    const importPath = path.join(this.homesDir, 'unified-exports.js');
    fs.writeFileSync(importPath, importContent);
    
    log('‚úÖ Fichier d\'imports unifi√© g√©n√©r√©', 'green');
  }

  generateFinalReport() {
    log('\nüìä RAPPORT DE MIGRATION AUTOMATIQUE', 'cyan');
    log('=' * 50, 'cyan');
    
    log(`üß© Composants migr√©s: ${this.stats.migrated}`, 'green');
    log(`üîÑ Mises √† jour: ${this.stats.updated}`, 'blue');
    log(`‚ùå Erreurs: ${this.stats.errors.length}`, 'red');

    if (this.stats.errors.length > 0) {
      log('\nüö® Erreurs rencontr√©es:', 'red');
      this.stats.errors.forEach(error => {
        log(`   ‚Ä¢ ${error}`, 'red');
      });
    }

    log('\nüéØ √âTAPES SUIVANTES:', 'cyan');
    log('1. ‚úÖ V√©rifier les composants migr√©s dans shared/', 'yellow');
    log('2. üîß Adapter la logique sp√©cifique de chaque composant', 'yellow');
    log('3. üß™ Tester le rendu avec le nouveau syst√®me', 'yellow');
    log('4. üìö Mettre √† jour la documentation', 'yellow');
    log('5. üóëÔ∏è  Supprimer les anciens r√©pertoires (apr√®s validation)', 'yellow');

    log('\n‚ú® Migration automatique termin√©e!', 'green');
    log(`\nüìÅ Composants disponibles dans: ${this.sharedDir}`, 'cyan');
    log(`‚öôÔ∏è Configuration g√©n√©r√©e dans: ${this.projectRoot}/lib/auto-generated-configs.js`, 'cyan');
    log(`üì¶ Imports centralis√©s dans: ${this.homesDir}/unified-exports.js`, 'cyan');
  }
}

// Ex√©cution du script
async function main() {
  const migrator = new AutoMigrator();
  await migrator.autoMigrate();
}

if (require.main === module) {
  main().catch(error => {
    log(`üí• Erreur fatale: ${error.message}`, 'red');
    process.exit(1);
  });
}

module.exports = AutoMigrator;
